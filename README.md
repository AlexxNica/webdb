# InjestDB

A peer-to-peer database for dat:// applications.

#### Example

Setup a database for social profiles, which can publish status updates and like other users' posts.

```js
const Injest = require('injestdb')
var db = new Injest('social-profiles')
db.schema({
  version: 1,
  broadcasts: {
    primaryKey: 'createdAt',
    index: [
      'createdAt',
      '_origin+createdAt' // compound index. '_origin' is an autogenerated attribute which represets the URL of the authoring archive
    ],
    validator: record => {
      assert(typeof record.text === 'string')
      assert(typeof record.createdAt === 'number')
      return record
    }
  },
  likes: {
    primaryKey: 'createdAt',
    index: 'targetUrl',
    validator: record => {
      assert(typeof record.targetUrl === 'string')
      return record
    }
  },
  profile: {
    singular: true,
    index: 'name',
    validator: record => {
      assert(typeof record.name === 'string')
      return {
        name: record.name,
        description: isString(record.description) ? record.description : '',
        avatarUrl: isString(record.avatarUrl) ? record.avatarUrl : ''
      }
    }
  }
})
```

Next we add source archives to be ingested (added ot the dataset). The source archives are persisted in IndexedDB, so this doesn't have to be done every run.

```js
await db.addArchives([alicesUrl, bobsUrl, carlasDatArchive], {prepare: true})
```

Now we can begin querying the database for records.

```js
// get the first profile record where name === 'bob'
var bobProfile = await db.profiles.get('name', 'bob')

// get all profile records which match this query
var bobProfiles = await db.profiles
  .where('name')
  .equalsIgnoreCase('bob')
  .toArray()

// get the 30 latest broadcasts from all source archives
var recentBroadcasts = await db.broadcasts
  .orderBy('createdAt')
  .reverse() // most recent first
  .limit(30)
  .toArray()

// get the 30 latest broadcasts by a specific archive (bob)
// - this uses a compound index to filter by origin, and then sort by createdAt
var bobsRecentBroadcasts = await db.broadcasts
  .where('_origin+createdAt')
  .between([bobsUrl, ''], [bobsUrl, '\uffff'])
  .reverse() // most recent first
  .limit(30)
  .toArray()

// get the # of likes for a broadcast
var numLikes = await db.likes
  .where('targetUrl').equals(bobsRecentBroadcasts[0]._url) // _url is an autogenerated attribute which represents the URL of the record
  .count()
```

We can also use Injest to create, modify, and delete records (and their matching files).

```js
// update bob's name
await db.profiles.update(bobsUrl, {name: 'robert'})

// publish a new broadcast for bob
var broadcastUrl = await db.broadcasts.add(bobsUrl, {
  text: 'Hello!',
  createdAt: Date.now()
})

// modify the broadcast
await db.broadcasts.update(broadcastUrl, {text: 'Hello world!'})

// like the broadcast
await db.likes.add(bobsUrl, {
  targetUrl: broadcastUrl,
  createdAt: Date.now()
})

// delete the broadcast
await db.broadcasts.delete(broadcastUrl)

// delete all likes on the broadcast (that we control)
await db.likes
  .where({targetUrl: broadcastUrl})
  .delete()
```

## TODOs

Injest is still in development.

 - [x] Indexer
 - [x] Core query engine
 - [x] Persisted tables and table reindex on schema change
 - [x] Mutation methods (add/update/delete)
 - [ ] Events
 - [x] Multikey indexes
 - [ ] Validation: filename must match primaryKey on non-singular tables
 - [ ] Support for .or() queries
 - [ ] Complete documentation

## API quick reference

```js
var db = new InjestDB(name)
db.open() => Promise<Void>
db.close() => Promise<Void>
db.schema(Object) => Promise<Void>
db.addArchive(url|DatArchive, {prepare: Boolean}) => Promise<Void>
db.addArchives(Array<url|DatArchive>, {prepare: Boolean}) => Promise<Void>
db.removeArchive(url|DatArchive) => Promise<Void>
db.prepareArchive(url|DatArchive)
db.listArchives() => Promise<url>
InjestDB.list() => Promise<Void>
InjestDB.delete(name) => Promise<Void>

db.{table} => InjestTable
InjestTable#add(archive, record) => Promise<url>
InjestTable#count() => Promise<Number>
InjestTable#delete(url) => Promise<url>
InjestTable#each(Function) => Promise<Void>
InjestTable#filter(Function) => InjestRecordset
InjestTable#get(url) => Promise<Object>
InjestTable#get(archive) => Promise<Object>
InjestTable#get(archive, key) => Promise<Object>
InjestTable#get(index, value) => Promise<Object>
InjestTable#isRecordFile(String) => Boolean
InjestTable#limit(Number) => InjestRecordset
InjestTable#listRecordFiles(Archive) => Promise<Object>
InjestTable#name => String
InjestTable#offset(Number) => InjestRecordset
InjestTable#orderBy(index) => InjestRecordset
InjestTable#put(url, record) => Promise<url>
InjestTable#reverse() => InjestRecordset
InjestTable#schema => Object
InjestTable#toArray() => Promise<Array>
InjestTable#toCollection() => InjestRecordset
InjestTable#update(record) => Promise<Number>
InjestTable#update(url, updates) => Promise<Number>
InjestTable#update(archive, updates) => Promise<Number>
InjestTable#update(archive, key, updates) => Promise<Number>
InjestTable#upsert(url, record) => Promise<Void | url>
InjestTable#upsert(archive, record) => Promise<Void | url>
InjestTable#where(index) => InjestWhereClause

InjestWhereClause#above(lowerBound) => InjestRecordset
InjestWhereClause#aboveOrEqual(lowerBound) => InjestRecordset
InjestWhereClause#anyOf(Array|...args) => InjestRecordset
InjestWhereClause#anyOfIgnoreCase(Array|...args) => InjestRecordset
InjestWhereClause#below(upperBound) => InjestRecordset
InjestWhereClause#belowOrEqual(upperBound) => InjestRecordset
InjestWhereClause#between(lowerBound, upperBound, {includeUpper, includeLower}) => InjestRecordset
InjestWhereClause#equals(value) => InjestRecordset
InjestWhereClause#equalsIgnoreCase(value) => InjestRecordset
InjestWhereClause#noneOf(Array|...args) => InjestRecordset
InjestWhereClause#notEqual(value) => InjestRecordset
InjestWhereClause#startsWith(value) => InjestRecordset
InjestWhereClause#startsWithAnyOf(Array|...args) => InjestRecordset
InjestWhereClause#startsWithAnyOfIgnoreCase(Array|...args) => InjestRecordset
InjestWhereClause#startsWithIgnoreCase(value) => InjestRecordset

InjestRecordset#clone() => InjestRecordset
InjestRecordset#count() => Promise<Number>
InjestRecordset#delete() => Promise<Number>
InjestRecordset#distinct() => InjestRecordset
InjestRecordset#each(Function) => Promise<Void>
InjestRecordset#eachKey(Function) => Promise<Void>
InjestRecordset#eachUrl(Function) => Promise<Void>
InjestRecordset#filter(Function) => InjestRecordset
InjestRecordset#first() => Promise<Object>
InjestRecordset#keys() => Promise<Array<String>>
InjestRecordset#last() => Promise<Object>
InjestRecordset#limit(Number) => InjestRecordset
InjestRecordset#offset(Number) => InjestRecordset
InjestRecordset#or(index) => InjestWhereClause
InjestRecordset#put(Object) => Promise<Number>
InjestRecordset#urls() => Promise<Array<String>>
InjestRecordset#reverse() => InjestRecordset
InjestRecordset#toArray() => Promise<Array<Object>>
InjestRecordset#uniqueKeys() => Promise<Array<String>>
InjestRecordset#until(Function) => InjestRecordset
InjestRecordset#update(Object|Function) => Promise<Number>
InjestRecordset#where(index) => InjestWhereClause
```

## API

### db.schema(definition)

```js
{
  version: Number, // the version # of the schema, should increment by 1 on each change

  [tableName]: {
    // is there only one record-file per archive?
    // - if true, will look for the file at `/${tableName}.json`
    // - if false, will look for files at `/${tableName}/*.json`
    singular: Boolean,

    // attribute to build filenames for newly-created records
    // ie `/${tableName}/${record[primaryKey]}.json`
    // only required if !singular
    primaryKey: String, 

    // specify which fields are indexed for querying
    // each is a keypath, see https://www.w3.org/TR/IndexedDB/#dfn-key-path
    // can specify compound indexes with a + separator in the keypath
    // eg one index               - index: 'firstName' 
    // eg two indexes             - index: ['firstName', 'lastName']
    // eg add a compound index    - index: ['firstName', 'lastName', 'firstName+lastName']
    // eg index an array's values - index: ['firstName', '*favoriteFruits']
    index: String|Array<String>,

    // validator & sanitizer
    // takes the ingested file (must be valid json)
    // returns the record to be stored
    // returns falsy or throws to not store the record
    validator: Function(Object) => Object
  }
}
```

## How it works

InjestDB abstracts over the [DatArchive API](https://beakerbrowser.com/docs/apis/dat.html) to provide a simple database-like interface. Put another way, it uses the filesystem to provide a Tables and Records interface. Injest is based heavily on [Dexie.js](https://github.com/dfahlander/Dexie.js) and built using IndexedDB.

Injest works by scanning a set of origin archives for files that match a path pattern. Those files are indexed ("ingested") so that they can be queried easily. Injest also provides a simple interface for adding, editing, and removing records on the archives that the local user owns.

#### Goals

 - Simplify data storage and aggregate querying over multiple dat archives
 - Provide complex queries with ranges, partial matches, and logical combinations (AND, OR)

#### Glossary

 - **Archive**: a Dat archive. Has its own security origin. Contains many records.
 - **Record**: an entry in a Table which is derived from a single file in an Archive.
 - **Table**: a namespace of Records which are aggregated across many Archives.
 - **Recordset**: a set of Records which have been returned by a Table query.
 - **Origin Archive**: an Archive that has been added to the database as a origin of Records.
 - **Ingest**: to process a file and index it as a Record in a Table.
