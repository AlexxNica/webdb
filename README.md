# Injest - Dat archive database

Abstracts over the [DatArchive API](https://beakerbrowser.com/docs/apis/dat.html) to provide a simple database-like interface. Put another way, it hides the filesystem to provide a Tables and Records metaphor. Forked from [Dexie.js](https://github.com/dfahlander/Dexie.js) and built using IndexedDB.

Injest works by scanning a set of source archives for files that match a path pattern. Those files are indexed ("ingested") so that they can be queried easily. Injest also provides a simple interface for adding, editing, and removing records on the archives that the local user owns.

#### Goals

 - Simplify data storage and aggregate querying over multiple dat archives
 - Provide complex queries with ranges, partial matches, and logical combinations (AND, OR)

#### Glossary

 - **Archive**: a Dat archive. Has its own security origin. Contains many records.
 - **Record**: an entry in a Table which is derived from a single file in an Archive.
 - **Table**: a namespace of Records which are aggregated across many Archives.
 - **Recordset**: a set of Records which have been returned by a Table query.
 - **Source Archive**: an Archive that has been added to the database as a source of Records.
 - **Ingest**: to process a file and index it as a Record in a Table.


#### Example

Setup a database for social profiles, which can publish status updates and like other users' posts.

```js
const Injest = require('injestdb')

// setup a database for social profiles
// profile sites will
//  - publish user-profiles at /profile.json
//  - publish status-updates at /broadcasts/*.json
//  - publish 'likes' at /likes/*.json

var db = new Injest('social-profiles') // give the DB a name
db.schema({
  version: 1,

  // profiles table
  profiles: {
    // ingested from one file per archive: /profile.json
    path: '/profile.json',
    // can query & sort against the name attribute
    index: 'name',

    // validator & sanitizer
    // takes the ingested file (must be valid json)
    // returns the record to be stored
    // returns falsy or throws to not store the record
    validator: record => {
      if (!(record.name && typeof record.name === 'string')) {
        return false
      }
      return {
        name: record.name,
        description: isString(record.description) ? record.description : '',
        avatarUrl: isString(record.avatarUrl) ? record.avatarUrl : ''
      }
    }
  },

  // broadcasts table (aka status updates)
  broadcasts: {
    // all of the files that match: /broadcasts/*.json
    path: '/broadcasts/*.json',
    // helper to build the path for a given record
    buildPath: record => `/broadcasts/${record.createdAt}.json`,
    index: [
      'createdAt',
      'origin+createdAt' // compound index. 'origin' is an autogenerated attribute
    ],
    validator: record => { /*...*/ }
  },

  // likes table
  likes: {
    path: '/likes/*.json',
    buildPath: record => `/likes/${record.createdAt}.json`,
    index: 'targetUrl',
    validator: record => { /*...*/ }
  }
})
```

Next we add source archives to be ingested (added ot the dataset). The source archives are persisted in IndexedDB, so this doesn't have to be done every run.

```js
await Promise.all([
  db.sources.add(bobsUrl),
  db.sources.add(alicesUrl),
  db.sources.add(carlasDatArchive)
])
```

Now we can begin querying the database for records.

```js
// get the first profile record to match this query
var bobProfile = await db.profiles.where({name: 'bob'}).first()

// get all profile records which match this query
var bobProfiles = await db.profiles
  .where('name')
  .equalsIgnoreCase('bob')
  .toArray()

// get the 30 latest broadcasts from all source archives
var recentBroadcasts = await db.broadcasts
  .orderBy('createdAt')
  .reverse() // most recent first
  .limit(30)
  .toArray()

// get the 30 latest broadcasts by a specific archive (bob)
// - this uses a compound index to filter by origin, and then sort by createdAt
var bobsRecentBroadcasts = await db.broadcasts
  .where('origin+createdAt')
  .between([bobsUrl, ''], [bobsUrl, '\uffff'])
  .reverse() // most recent first
  .limit(30)
  .toArray()

// get the # of likes for a broadcast
var numLikes = await db.likes
  .where({targetUrl: bobsRecentBroadcasts[0].url}) // url is a specially-added attribute, similar to origin
  .count()
```

We can also use Injest to create, modify, and delete records (and their matching files).

```js
// update bob's name
await db.profiles.update(bobsUrl, {name: 'robert'})

// publish a new broadcast for bob
var broadcastUrl = await db.broadcasts.add(bobsUrl, {
  text: 'Hello!',
  createdAt: Date.now()
})

// modify the broadcast
await db.broadcasts.update(broadcastUrl, {text: 'Hello world!'})

// like the broadcast
await db.likes.add(bobsUrl, {
  targetUrl: broadcastUrl,
  createdAt: Date.now()
})

// delete the broadcast
await db.broadcasts.delete(broadcastUrl)

// delete all likes on the broadcast (that we control)
await db.likes
  .where({targetUrl: broadcastUrl})
  .delete()
```

#### API quick reference

```js
db.schema(Object) => Promise<Void>
db.sources.add(url|DatArchive) => Promise<Void>
db.sources.remove(url|DatArchive) => Promise<Void>
db.sources.list() => Promise<url>

db.{table} => InjestTable
InjestTable#add(url|DatArchive, record) => Promise<url>
InjestTable#count() => Promise<Number>
InjestTable#delete(url|DatArchive, record) => Promise<url>
InjestTable#each(Function) => Promise<Void>
InjestTable#filter(Function) => InjestRecordset
InjestTable#get(path | query) => Promise<InjestArchive>
InjestTable#limit(Number) => InjestRecordset
InjestTable#name => String
InjestTable#offset(Number) => InjestRecordset
InjestTable#orderBy(index) => InjestRecordset
InjestTable#reverse() => InjestRecordset
InjestTable#schema => Object
InjestTable#toArray() => Promise<Array>
InjestTable#toCollection() => InjestRecordset
InjestTable#update(url|DatArchive, record) => Promise<url>
InjestTable#where(index|query) => InjestWhereClause|InjestRecordset

InjestWhereClause#above(lowerBound) => InjestRecordset
InjestWhereClause#aboveOrEqual(lowerBound) => InjestRecordset
InjestWhereClause#anyOf(Array|...args) => InjestRecordset
InjestWhereClause#anyOfIgnoreCase(Array|...args) => InjestRecordset
InjestWhereClause#below(upperBound) => InjestRecordset
InjestWhereClause#belowOrEqual(upperBound) => InjestRecordset
InjestWhereClause#between(lowerBound, upperBound, opts) => InjestRecordset
InjestWhereClause#equals(value) => InjestRecordset
InjestWhereClause#equalsIgnoreCase(value) => InjestRecordset
InjestWhereClause#inAnyRange(ranges, opts) => InjestRecordset
InjestWhereClause#noneOf(Array|...args) => InjestRecordset
InjestWhereClause#notEqual(value) => InjestRecordset
InjestWhereClause#startsWith(value) => InjestRecordset
InjestWhereClause#startsWithAnyOf(Array|...args) => InjestRecordset
InjestWhereClause#startsWithAnyOfIgnoreCase(Array|...args) => InjestRecordset
InjestWhereClause#startsWithIgnoreCase(value) => InjestRecordset

InjestRecordset#clone() => InjestRecordset
InjestRecordset#count() => Promise<Number>
InjestRecordset#delete() => Promise<Number>
InjestRecordset#distinct() => InjestRecordset
InjestRecordset#each(Function) => Promise<Void>
InjestRecordset#eachKey(Function) => Promise<Void>
InjestRecordset#eachUrl(Function) => Promise<Void>
InjestRecordset#filter(Function) => InjestRecordset
InjestRecordset#first() => Promise<Object>
InjestRecordset#keys() => Promise<Array<String>>
InjestRecordset#last() => Promise<Object>
InjestRecordset#limit(Number) => InjestRecordset
InjestRecordset#offset(Number) => InjestRecordset
InjestRecordset#or(index) => InjestWhereClause
InjestRecordset#urls() => Promise<Array<String>>
InjestRecordset#reverse() => InjestRecordset
InjestRecordset#toArray() => Promise<Array<Object>>
InjestRecordset#uniqueKeys() => Promise<Array<String>>
InjestRecordset#until(Function) => InjestRecordset
InjestRecordset#update(Object|Function) => Promise<Number>
```