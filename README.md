# Injest - Dat archive database

Abstracts over the [DatArchive API](https://beakerbrowser.com/docs/apis/dat.html) to provide a simple database-like interface. Put another way, it hides the filesystem to provide a Tables and Records metaphor. Forked from [Dexie.js](https://github.com/dfahlander/Dexie.js) and built using IndexedDB.

Injest works by scanning a set of origin archives for files that match a path pattern. Those files are indexed ("ingested") so that they can be queried easily. Injest also provides a simple interface for adding, editing, and removing records on the archives that the local user owns.

#### Goals

 - Simplify data storage and aggregate querying over multiple dat archives
 - Provide complex queries with ranges, partial matches, and logical combinations (AND, OR)

#### Glossary

 - **Archive**: a Dat archive. Has its own security origin. Contains many records.
 - **Record**: an entry in a Table which is derived from a single file in an Archive.
 - **Table**: a namespace of Records which are aggregated across many Archives.
 - **Recordset**: a set of Records which have been returned by a Table query.
 - **Origin Archive**: an Archive that has been added to the database as a origin of Records.
 - **Ingest**: to process a file and index it as a Record in a Table.


#### Example

Setup a database for social profiles, which can publish status updates and like other users' posts.

```js
const Injest = require('injestdb')

// setup a database for social profiles
// profile sites will
//  - publish user-profiles at /profile.json
//  - publish status-updates at /broadcasts/*.json
//  - publish 'likes' at /likes/*.json

var db = new Injest('social-profiles') // give the DB a name
db.schema({
  version: 1,

  // broadcasts table (aka status updates, aka tweets)
  // generated from files that match /broadcasts/*.json
  broadcasts: {
    primaryKey: 'createdAt', // used to generate filenames of new records, eg `/broadcasts/${record.createdAt}.json`
    index: [
      'createdAt',
      '_origin+createdAt' // compound index. '_origin' is an autogenerated attribute
    ],
    validator: record => { /*...*/ }
  },

  // likes table
  // generated from files that match /likes/*.json
  likes: {
    primaryKey: 'createdAt', // used to generate filenames of new records, eg `/likes/${record.createdAt}.json`
    index: 'targetUrl',
    validator: record => { /*...*/ }
  },

  // profile table
  // generated from one file per archive: /profile.json
  profile: {
    // one record per archive
    singular: true,

    // can query & sort against the name attribute
    index: 'name',

    // validator & sanitizer
    // takes the ingested file (must be valid json)
    // returns the record to be stored
    // returns falsy or throws to not store the record
    validator: record => {
      if (!(record.name && typeof record.name === 'string')) {
        return false
      }
      return {
        name: record.name,
        description: isString(record.description) ? record.description : '',
        avatarUrl: isString(record.avatarUrl) ? record.avatarUrl : ''
      }
    }
  }
})
```

Next we add source archives to be ingested (added ot the dataset). The source archives are persisted in IndexedDB, so this doesn't have to be done every run.

```js
await Promise.all([
  db.addArchive(bobsUrl),
  db.addArchive(alicesUrl),
  db.addArchive(carlasDatArchive)
])
```

Now we can begin querying the database for records.

```js
// get the first profile record to match this query
var bobProfile = await db.profiles.where({name: 'bob'}).first()

// get all profile records which match this query
var bobProfiles = await db.profiles
  .where('name')
  .equalsIgnoreCase('bob')
  .toArray()

// get the 30 latest broadcasts from all source archives
var recentBroadcasts = await db.broadcasts
  .orderBy('createdAt')
  .reverse() // most recent first
  .limit(30)
  .toArray()

// get the 30 latest broadcasts by a specific archive (bob)
// - this uses a compound index to filter by origin, and then sort by createdAt
var bobsRecentBroadcasts = await db.broadcasts
  .where('_origin+createdAt')
  .between([bobsUrl, ''], [bobsUrl, '\uffff'])
  .reverse() // most recent first
  .limit(30)
  .toArray()

// get the # of likes for a broadcast
var numLikes = await db.likes
  .where({targetUrl: bobsRecentBroadcasts[0]._url}) // _url is a specially-added attribute, similar to _origin
  .count()
```

We can also use Injest to create, modify, and delete records (and their matching files).

```js
// update bob's name
await db.profiles.update(bobsUrl, {name: 'robert'})

// publish a new broadcast for bob
var broadcastUrl = await db.broadcasts.add(bobsUrl, {
  text: 'Hello!',
  createdAt: Date.now()
})

// modify the broadcast
await db.broadcasts.update(broadcastUrl, {text: 'Hello world!'})

// like the broadcast
await db.likes.add(bobsUrl, {
  targetUrl: broadcastUrl,
  createdAt: Date.now()
})

// delete the broadcast
await db.broadcasts.delete(broadcastUrl)

// delete all likes on the broadcast (that we control)
await db.likes
  .where({targetUrl: broadcastUrl})
  .delete()
```

#### API quick reference

```js
var db = new InjestDB(name)
db.open() => Promise<Void>
db.close() => Promise<Void>
db.schema(Object) => Promise<Void>
db.addArchive(url|DatArchive) => Promise<Void>
db.addArchives(Array<url|DatArchive>) => Promise<Void>
db.removeArchive(url|DatArchive) => Promise<Void>
db.listArchives() => Promise<url>
InjestDB.list() => Promise<Void>
InjestDB.delete(name) => Promise<Void>

db.{table} => InjestTable
InjestTable#add(url, record) => Promise<url>
InjestTable#count() => Promise<Number>
InjestTable#delete(url) => Promise<url>
InjestTable#each(Function) => Promise<Void>
InjestTable#filter(Function) => InjestRecordset
InjestTable#get(url | query) => Promise<InjestArchive>
InjestTable#isRecordFile(String) => Boolean
InjestTable#limit(Number) => InjestRecordset
InjestTable#listRecordFiles(Archive) => Promise<Object>
InjestTable#name => String
InjestTable#offset(Number) => InjestRecordset
InjestTable#orderBy(index) => InjestRecordset
InjestTable#put(url, record) => Promise<url>
InjestTable#reverse() => InjestRecordset
InjestTable#schema => Object
InjestTable#toArray() => Promise<Array>
InjestTable#toCollection() => InjestRecordset
InjestTable#update(url, record) => Promise<url>
InjestTable#where(index|query) => InjestWhereClause|InjestRecordset

InjestWhereClause#above(lowerBound) => InjestRecordset
InjestWhereClause#aboveOrEqual(lowerBound) => InjestRecordset
InjestWhereClause#anyOf(Array|...args) => InjestRecordset
InjestWhereClause#anyOfIgnoreCase(Array|...args) => InjestRecordset
InjestWhereClause#below(upperBound) => InjestRecordset
InjestWhereClause#belowOrEqual(upperBound) => InjestRecordset
InjestWhereClause#between(lowerBound, upperBound, {includeUpper, includeLower}) => InjestRecordset
InjestWhereClause#equals(value) => InjestRecordset
InjestWhereClause#equalsIgnoreCase(value) => InjestRecordset
InjestWhereClause#noneOf(Array|...args) => InjestRecordset
InjestWhereClause#notEqual(value) => InjestRecordset
InjestWhereClause#startsWith(value) => InjestRecordset
InjestWhereClause#startsWithAnyOf(Array|...args) => InjestRecordset
InjestWhereClause#startsWithAnyOfIgnoreCase(Array|...args) => InjestRecordset
InjestWhereClause#startsWithIgnoreCase(value) => InjestRecordset

InjestRecordset#clone() => InjestRecordset
InjestRecordset#count() => Promise<Number>
InjestRecordset#delete() => Promise<Number>
InjestRecordset#distinct() => InjestRecordset
InjestRecordset#each(Function) => Promise<Void>
InjestRecordset#eachKey(Function) => Promise<Void>
InjestRecordset#eachUrl(Function) => Promise<Void>
InjestRecordset#filter(Function) => InjestRecordset
InjestRecordset#first() => Promise<Object>
InjestRecordset#keys() => Promise<Array<String>>
InjestRecordset#last() => Promise<Object>
InjestRecordset#limit(Number) => InjestRecordset
InjestRecordset#offset(Number) => InjestRecordset
InjestRecordset#or(index) => InjestWhereClause
InjestRecordset#put(Object) => Promise<Number>
InjestRecordset#urls() => Promise<Array<String>>
InjestRecordset#reverse() => InjestRecordset
InjestRecordset#toArray() => Promise<Array<Object>>
InjestRecordset#uniqueKeys() => Promise<Array<String>>
InjestRecordset#until(Function) => InjestRecordset
InjestRecordset#update(Object|Function) => Promise<Number>
InjestRecordset#where(index|query) => InjestWhereClause|InjestRecordset
```

## API

### db.schema(definition)

```js
{
  version: Number, // the version # of the schema, should increment by 1 on each change

  [tableName]: {
    // is there only one record-file per archive?
    // - if true, will look for the file at `/${tableName}.json`
    // - if false, will look for files at `/${tableName}/*.json`
    singular: Boolean,

    // attribute to build filenames for newly-created records
    // ie `/${tableName}/${record[primaryKey]}.json`
    // only required if !singular
    primaryKey: String, 

    // specify which fields are indexed for querying
    // each is a keypath, see https://www.w3.org/TR/IndexedDB/#dfn-key-path
    // can specify compound indexes with a + separator in the keypath
    // eg one index            - index: 'firstName' 
    // eg two indexes          - index: ['firstName', 'lastName']
    // eg add a compound index - index: ['firstName', 'lastName', 'firstName+lastName']
    index: String|Array<String>,

    // validator & sanitizer
    // takes the ingested file (must be valid json)
    // returns the record to be stored
    // returns falsy or throws to not store the record
    validator: Function(Object) => Object
  }
}
```